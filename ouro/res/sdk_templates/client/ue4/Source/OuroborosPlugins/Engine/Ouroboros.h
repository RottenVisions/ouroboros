// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "KBECommon.h"
#include "ServerErrorDescrs.h"
#include "Interfaces.h"
#include "KBETicker.h"

namespace Ouroboros
{

class OuroborosArgs;
class Entity;
class NetworkInterfaceBase;
class MemoryStream;
class EncryptionFilter;

/*
	This is the core module of the Ouroboros plugin.
	This includes network creation, persistence protocols, management of entities, and the creation of externally callable interfaces.

	Some places to refer to:
	http://www.ouroboros.org/docs/programming/clientsdkprogramming.html
	http://www.ouroboros.org/docs/programming/ouro_message_format.html
*/
class OUROBOROSPLUGINS_API OuroborosApp : public InterfaceConnect
{
public:
	OuroborosApp();
	OuroborosApp(OuroborosArgs* pArgs);
	virtual ~OuroborosApp();
	
public:
	static OuroborosApp& getSingleton();
	static void destroyOuroborosApp();
public:
	bool isInitialized() const {
		return pArgs_ != NULL;
	}

	bool initialize(OuroborosArgs* pArgs);
	void destroy();
	void reset();
	
	void installUKBETicker();
	void uninstallUKBETicker();

	NetworkInterfaceBase* pNetworkInterface() const {
		return pNetworkInterface_;
	}

	void _closeNetwork();

	const TArray<uint8>& serverdatas() const
	{
		return serverdatas_;
	}

	void entityServerPos(const FVector& pos)
	{
		entityServerPos_ = pos;
	}

	OuroborosArgs* getInitArgs() const
	{
		return pArgs_;
	}

	void installEvents();

	void resetMessages();

	static bool validEmail(const FString& strEmail);

	/*
		Get an error description by error id
	*/
	FString serverErr(uint16 id);

	Entity* player();
	Entity* findEntity(int32 entityID);

	/*
		Server error description imported
	*/
	void Client_onImportServerErrorsDescr(MemoryStream& stream)
	{
		// No need to implement, static code has been generated by the plugin
	}

	/*
		Import the binary message from the server to the client message protocol
	*/
	void Client_onImportClientMessages(MemoryStream& stream)
	{
		// No need to implement, static code has been generated by the plugin
	}

	/*
		Import the binary message from the server to the client message protocol
	*/
	void Client_onImportClientEntityDef(MemoryStream& stream)
	{
		// No need to implement, static code has been generated by the plugin
	}

	void Client_onImportClientSDK(MemoryStream& stream);

	/**
		The main loop processing function of the plugin
	*/
	void process();

	/*
		Send heartbeat to the server and synchronize role information to the server
	*/
	void sendTick();

	/**
		Log in to the server, you must log in to complete the loginapp and gateway (baseapp), the login process is completed.
	*/
	bool login(const FString& username, const FString& password, const TArray<uint8>& datas);
	virtual void onConnectCallback(FString ip, uint16 port, bool success, int userdata) override;

	/**
		Log in to baseapp
	*/
	bool logout();

	/*
		Account creation returns results
	*/
	void Client_onCreateAccountResult(MemoryStream& stream);

	/*
				Create an account
	*/
	bool createAccount(const FString& username, const FString& password, const TArray<uint8>& datas);

	/*
		Reset password via loginapp
	*/
	void resetPassword(const FString& username);
	void onOpenLoginapp_resetpassword();
	void onConnectTo_resetpassword_callback(FString ip, uint16 port, bool success);
	void Client_onReqAccountResetPasswordCB(uint16 failcode);

	/*
		Bind email via baseapp
	*/
	void bindAccountEmail(const FString& emailAddress);
	void Client_onReqAccountBindEmailCB(uint16 failcode);

	/*
		Set a new password, through baseapp, the player must log in to the online operation so it is baseapp.
	*/
	void newPassword(const FString& old_password, const FString& new_password);
	void Client_onReqAccountNewPasswordCB(uint16 failcode);

	/*
	Re-login to the gateway (baseapp)
	Some mobile applications are easy to drop, and you can use this feature to quickly re-establish communication with the server.
	*/
	void reloginBaseapp();
	void onReloginTo_baseapp_callback(FString ip, uint16 port, bool success);

	/*
		Login loginapp failed
	*/
	void Client_onLoginFailed(MemoryStream& stream);

	/*
		Login loginapp succeeded
	*/
	void Client_onLoginSuccessfully(MemoryStream& stream);

	/*
		Login to baseapp failed
	*/
	void Client_onLoginBaseappFailed(uint16 failedcode);

	/*
		Re-login to baseapp failed
	*/
	void Client_onReloginBaseappFailed(uint16 failedcode);

	/*
		Login to baseapp succeeded
	*/
	void Client_onReloginBaseappSuccessfully(MemoryStream& stream);

	void hello();
	void Client_onHelloCB(MemoryStream& stream);

	void Client_onVersionNotMatch(MemoryStream& stream);
	void Client_onScriptVersionNotMatch(MemoryStream& stream);

	/*
		Kicked out by the server
	*/
	void Client_onKicked(uint16 failedcode);

	/*
		Server heartbeat callback
	*/
	void Client_onAppActiveTickCB();

	/*
		Server notification creates a role
	*/
	void Client_onCreatedProxies(uint64 rndUUID, int32 eid, FString& entityType);

	/*
		The server notifies the mandatory destruction of an entity
	*/
	void Client_onEntityDestroyed(int32 eid);

	/*
		The server updates the entity attribute data in an optimized manner.
	*/
	void Client_onUpdatePropertysOptimized(MemoryStream& stream);

	/*
		The server updates the entity attribute data.
	*/
	void Client_onUpdatePropertys(MemoryStream& stream);

	/*
		The server uses the optimized method to call the entity method.
	*/
	void Client_onRemoteMethodCallOptimized(MemoryStream& stream);

	/*
		Server call entity method
	*/
	void Client_onRemoteMethodCall(MemoryStream& stream);

	/*
		Tell the client: You are currently responsible for (or cancel) controlling who's displacement synchronization
	*/
	void Client_onControlEntity(ENTITY_ID eid, int8 isControlled);

	/*
		The server initializes the client's spacedata. For spacedata, please refer to the API.
	*/
	void Client_initSpaceData(MemoryStream& stream);
	FString getSpaceData(const FString& key);

	/*
		The server initializes the client's spacedata. For spacedata, please refer to the API.
	*/
	void Client_setSpaceData(uint32 spaceID, const FString& key, const FString& value);

	/*
		The server deletes the client's spacedata. For spacedata, please refer to the API.
	*/
	void Client_delSpaceData(uint32 spaceID, const FString& key);

	/*
		Server notification stream data download starts
		Please refer to the API manual for onStreamDataStarted
	*/
	void Client_onStreamDataStarted(int16 id, uint32 datasize, FString descr);
	void Client_onStreamDataRecv(MemoryStream& stream);
	void Client_onStreamDataCompleted(int16 id);

	/*
		The server notifies an entity to enter the world (if the entity is the current player, the player is created in a space for the first time, and if it is another entity, the other entity enters the player's View)
	*/
	void Client_onEntityEnterWorld(MemoryStream& stream);

	/*
		The server uses an optimized way to notify an entity to leave the world (the player leaves the space if the entity is the current player, and the other entity leaves the player's View if it is another entity)
	*/
	void Client_onEntityLeaveWorldOptimized(MemoryStream& stream);

	/*
		The server notifies an entity to leave the world (the player leaves the space if the entity is the current player, and the other entity leaves the player's View if it is another entity)
	*/
	void Client_onEntityLeaveWorld(ENTITY_ID eid);

	/*
		The server notifies the current player that a new space has been entered.
	*/
	void Client_onEntityEnterSpace(MemoryStream& stream);

	/*
		The server notifies the current player that he has left the space.
	*/
	void Client_onEntityLeaveSpace(ENTITY_ID eid);

	/*
		The server updates the base position of the player, and the client calculates the coordinates of the entity around the player by using the base position plus the cheap value.
	*/
	void Client_onUpdateBasePos(float x, float y, float z);
	void Client_onUpdateBasePosXZ(float x, float z);
	void Client_onUpdateBaseDir(MemoryStream& stream);
	void Client_onUpdateData(MemoryStream& stream);

	/*
		The server forces the player's coordinates
		For example: use avatar.position=(0,0,0) on the server, or force the player to pull back to a position when the player's position and speed are abnormal.
	*/
	void Client_onSetEntityPosAndDir(MemoryStream& stream);

	void Client_onUpdateData_ypr(MemoryStream& stream);
	void Client_onUpdateData_yp(MemoryStream& stream);
	void Client_onUpdateData_yr(MemoryStream& stream);
	void Client_onUpdateData_pr(MemoryStream& stream);
	void Client_onUpdateData_y(MemoryStream& stream);
	void Client_onUpdateData_p(MemoryStream& stream);
	void Client_onUpdateData_r(MemoryStream& stream);
	void Client_onUpdateData_xz(MemoryStream& stream);
	void Client_onUpdateData_xz_ypr(MemoryStream& stream);
	void Client_onUpdateData_xz_yp(MemoryStream& stream);
	void Client_onUpdateData_xz_yr(MemoryStream& stream);
	void Client_onUpdateData_xz_pr(MemoryStream& stream);
	void Client_onUpdateData_xz_y(MemoryStream& stream);
	void Client_onUpdateData_xz_p(MemoryStream& stream);
	void Client_onUpdateData_xz_r(MemoryStream& stream);
	void Client_onUpdateData_xyz(MemoryStream& stream);
	void Client_onUpdateData_xyz_ypr(MemoryStream& stream);
	void Client_onUpdateData_xyz_yp(MemoryStream& stream);
	void Client_onUpdateData_xyz_yr(MemoryStream& stream);
	void Client_onUpdateData_xyz_pr(MemoryStream& stream);
	void Client_onUpdateData_xyz_y(MemoryStream& stream);
	void Client_onUpdateData_xyz_p(MemoryStream& stream);
	void Client_onUpdateData_xyz_r(MemoryStream& stream);

	void Client_onUpdateData_ypr_optimized(MemoryStream& stream);
	void Client_onUpdateData_yp_optimized(MemoryStream& stream);
	void Client_onUpdateData_yr_optimized(MemoryStream& stream);
	void Client_onUpdateData_pr_optimized(MemoryStream& stream);
	void Client_onUpdateData_y_optimized(MemoryStream& stream);
	void Client_onUpdateData_p_optimized(MemoryStream& stream);
	void Client_onUpdateData_r_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_ypr_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_yp_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_yr_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_pr_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_y_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_p_optimized(MemoryStream& stream);
	void Client_onUpdateData_xz_r_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_ypr_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_yp_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_yr_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_pr_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_y_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_p_optimized(MemoryStream& stream);
	void Client_onUpdateData_xyz_r_optimized(MemoryStream& stream);

private:
	void _updateVolatileData(ENTITY_ID entityID, float x, float y, float z, float yaw, float pitch, float roll, int8 isOnGround, bool isOptimized);

	bool initNetwork();

	void login_loginapp(bool noconnect);
	void onConnectTo_loginapp_login_callback(FString ip, uint16 port, bool success);
	void onLogin_loginapp();

	void login_baseapp(bool noconnect);
	void onConnectTo_baseapp_callback(FString ip, uint16 port, bool success);
	void onLogin_baseapp();


	void clearSpace(bool isall);
	void clearEntities(bool isall);


	void updatePlayerToServer();

	void onServerDigest();

	void addSpaceGeometryMapping(uint32 uspaceID, const FString& respath);

	void resetpassword_loginapp(bool noconnect);

	void createAccount_loginapp(bool noconnect);
	void onOpenLoginapp_createAccount();
	void onConnectTo_loginapp_create_callback(FString ip, uint16 port, bool success);

	/*
		Get the ID of the View entity by streaming data
	*/
	ENTITY_ID getViewEntityIDFromStream(MemoryStream& stream);

	/*
	The server updates the entity attribute data.
	*/
	void onUpdatePropertys_(ENTITY_ID eid, MemoryStream& stream);

	void onRemoteMethodCall_(ENTITY_ID eid, MemoryStream& stream);

public:
	SPACE_ID spaceID() const {
		return spaceID_;
	}

	ENTITY_ID entity_id() const {
		return entity_id_;
	}

	uint64 entity_uuid() const {
		return entity_uuid_;
	}

	const FString& entity_type() const {
		return entity_type_;
	}

	const FString& serverVersion() const {
		return serverVersion_;
	}

	const FString& clientVersion() const {
		return clientVersion_;
	}

	const FString& serverScriptVersion() const {
		return serverScriptVersion_;
	}

	const FString& clientScriptVersion() const {
		return clientScriptVersion_;
	}

	const FString& component() const {
		return component_;
	}

	const FString& currserver() const {
		return currserver_;
	}

	const FString& currstate() const {
		return currstate_;
	}

	typedef TMap<ENTITY_ID, Entity*> ENTITIES_MAP;
	ENTITIES_MAP& entities() {
		return entities_;
	}

protected:
	OuroborosArgs* pArgs_;
	NetworkInterfaceBase* pNetworkInterface_;

	FString username_;
	FString password_;

	// baseapp address assigned by the server
	FString baseappIP_;
	uint16 baseappTcpPort_;
	uint16 baseappUdpPort_;

	// current state
	FString currserver_;
	FString currstate_;

	// Binary information of the account binding when the server is running down and the client is used for login.
	// This information is extended by the user himself
	TArray<uint8> serverdatas_;
	TArray<uint8> clientdatas_;

	// communication protocol encryption, blowfish protocol
	TArray<uint8> encryptedKey_;

	// The version number of the server and client and the protocol MD5
	FString serverVersion_;
	FString clientVersion_;
	FString serverScriptVersion_;
	FString clientScriptVersion_;
	FString serverProtocolMD5_;
	FString serverEntitydefMD5_;

	// current player's entity id and entity category
	uint64 entity_uuid_;
	ENTITY_ID entity_id_;
	FString entity_type_;
	
	// The selection of this parameter must be consistent with the parameters of ouroboros_defs.xml::cellapp/aliasEntityID
	bool useAliasEntityID_;

	TArray<Entity*> controlledEntities_;

	// The player's location that was last synced by the server
	FVector entityServerPos_;

	// Space data, see the API manual on spaceData
	// https://github.com/ouroboros/ouroboros/tree/master/docs/api
	TMap<FString, FString> spacedatas_;
	
	// All entities are saved here, please refer to the API manual for the entities section.
	// https://github.com/ouroboros/ouroboros/tree/master/docs/api
	ENTITIES_MAP entities_;

	// When the player's View range is less than 256 entities, we can find the entity through a one-byte index.
	TArray<ENTITY_ID> entityIDAliasIDList_;
	TMap<ENTITY_ID, MemoryStream*> bufferedCreateEntityMessages_;

	// error description corresponding to all server error codes
	static ServerErrorDescrs serverErrs_;

	double lastTickTime_;
	double lastTickCBTime_;
	double lastUpdateToServerTime_;

	// the id of the space the player is currently in, and the resources corresponding to the space
	SPACE_ID spaceID_;
	FString spaceResPath_;
	bool isLoadedGeometry_;

	// According to the standard, each client part should contain this attribute
	FString component_;

	EncryptionFilter *pFilter_;
	UKBETicker *pUKBETicker_;

};

}
