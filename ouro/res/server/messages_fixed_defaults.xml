<root>
	<!--
		Due to the Ouroboros in the network Protocol ID are automatically generated by the system, if not use the matching SDK will be very difficult to with the service end of the docking Protocol.
		So the ouro provides a mechanism to allow the user to customize the network Protocol ID.
		In some cases this is relatively easy to use(for example: traditional Protocol for the way will have a Protocol table, the client matching Protocol table the Protocol and then parsing)

	For details, please refer to: http://ouroboros.org/cn/docs/configuration/messages_fixed.html
	-->

	<Machine::onFindInterfaceAddr>
		<id>1</id>
		<descr>Looking for component interface address.</descr>
	</Machine::onFindInterfaceAddr>

	<Machine::startserver>
		<id>2</id>
		<descr>Start the server.</descr>
	</Machine::startserver>

	<Machine::stopserver>
		<id>3</id>
		<descr>Stop the server.</descr>
	</Machine::stopserver>

	<Machine::onQueryAllInterfaceInfos>
		<id>4</id>
		<descr>Query all interface information.</descr>
	</Machine::onQueryAllInterfaceInfos>

	<Machine::onQueryMachines>
		<id>5</id>
		<descr>Query all machine processes.</descr>
	</Machine::onQueryMachines>

	<Machine::killserver>
		<id>6</id>
		<descr>Kill the server process.</descr>
	</Machine::killserver>

	<Loginapp::reqClose>
		<id>1</id>
		<descr>The client requested disconnection.</descr>
	</Loginapp::reqClose>

	<Loginapp::reqCreateAccount>
		<id>2</id>
		<descr>Client request to create an account.</descr>
		<arg>STRING</arg> <!-- Account name -->
		<arg>STRING</arg> <!-- Password -->
		<arg>UINT8_ARRAY</arg> <!-- 二Ary stream, and specifically by the developers to resolve -->
	</Loginapp::reqCreateAccount>

	<Loginapp::login>
		<id>3</id>
		<descr>The client requests the login to the server loginapp process, this process receives a request after legal verification will return a gateway address.</descr>
		<arg>STRING</arg> <!-- The front end of the Category 0:the Debug front-end, 1:phone front-end, n.. -->
		<arg>UINT8_ARRAY</arg> <!-- Specifically by the developers to resolve -->
		<arg>STRING</arg> <!-- Account name -->
		<arg>STRING</arg> <!-- Password -->
	</Loginapp::login>

	<Loginapp::hello>
		<id>4</id>
		<descr>hello。</descr>
	</Loginapp::hello>

	<Loginapp::importClientMessages>
		<id>5</id>
		<descr>The client requests the import of the Message Protocol.</descr>
	</Loginapp::importClientMessages>

	<Loginapp::reqCreateMailAccount>
		<id>6</id>
		<descr>Client request to create a mail account.</descr>
		<arg>STRING</arg> <!-- Account name -->
		<arg>STRING</arg> <!-- Password -->
		<arg>UINT8_ARRAY</arg> <!-- 二Ary stream, and specifically by the developers to resolve -->
	</Loginapp::reqCreateMailAccount>

	<Baseapp::hello>
		<id>200</id>
		<descr>hello。</descr>
	</Baseapp::hello>

	<Baseapp::reqClose>
		<id>201</id>
		<descr>The client requested disconnection.</descr>
	</Baseapp::reqClose>

	<Baseapp::loginBaseapp>
		<id>202</id>
		<descr>The client requests the login to the server gateway process, if legitimate, will enter the game.</descr>
		<arg>STRING</arg> <!-- Account name -->
		<arg>STRING</arg> <!-- Password -->
	</Baseapp::loginBaseapp>

	<Baseapp::reloginBaseapp>
		<id>204</id>
		<descr>Re-log in quick with the gateway to establish a interactive relationship(the premise is already logged in,
			After disconnecting in the server determines whether the front-end the Entity has not timed out the destruction
			of the premise can be fast and the server establish a connection and reach to manipulate the entity object)
		</descr>
		<arg>UINT64</arg> <!-- 64-bit random GUID code -->
		<arg>INT32</arg> <!-- ENTITY_ID -->
	</Baseapp::reloginBaseapp>

	<Baseapp::onRemoteCallCellMethodFromClient>
		<id>205</id>
		<descr>Call a cell a remote method.</descr>
		<arg>INT32</arg> <!-- entityID -->

		<arg>UINT8_ARRAY</arg> <!-- Method parameters binary stream, in particular by the method to parse the -->
	</Baseapp::onRemoteCallCellMethodFromClient>

	<Baseapp::onClientActiveTick>
		<id>206</id>
		<descr>The client's tick to.</descr>
	</Baseapp::onClientActiveTick>

	<Baseapp::importClientMessages>
		<id>207</id>
		<descr>The client requests the import of the Message Protocol.</descr>
	</Baseapp::importClientMessages>

	<Baseapp::importClientEntityDef>
		<id>208</id>
		<descr>Client entitydef export.</descr>
	</Baseapp::importClientEntityDef>

	<Base::onRemoteMethodCall>
		<id>301</id>
		<descr>Call one of the base remote method.</descr>
		<arg>INT32</arg> <!-- entityID -->
		<arg>UINT16</arg> <!-- Method ID -->
		<arg>UINT8_ARRAY</arg> <!-- Method parameters binary stream, in particular by the method to parse the -->
	</Base::onRemoteMethodCall>

	<Entity::onRemoteMethodCall>
		<id>302</id>
		<descr>Call a cell a remote method.</descr>
		<arg>INT32</arg> <!-- entityID -->
		<arg>UINT16</arg> <!-- Method ID -->
		<arg>UINT8_ARRAY</arg> <!-- Method parameters binary stream, in particular by the method to parse the -->
	</Entity::onRemoteMethodCall>

	<Proxy::onClientGetCell>
		<id>401</id>
		<descr>The server cell information of the initialization to the client,
			the client should inform the server that a callback for the server to determine.
		</descr>
	</Proxy::onClientGetCell>

	<Client::onCreateAccountResult>
		<id>501</id>
		<descr>Create account success and failure callbacks.</descr>
		<arg>UINT16</arg> <!-- Error code MERCURY_ERR_SRV_NO_READY:server not ready,
			MERCURY_ERR_ACCOUNT_CREATE:failure to create already exists,
			MERCURY_SUCCESS:account successfully created -->
		<arg>UINT8_ARRAY</arg> <!-- Binary stream, specifically by the developers to resolve -->
	</Client::onCreateAccountResult>

	<Client::onLoginSuccessfully>
		<id>502</id>
		<descr>Client login to loginapp, the server returns success.</descr>
		<arg>STRING</arg> <!-- Internal account name -->
		<arg>STRING</arg> <!-- The gateway ip address -->
		<arg>UINT16</arg> <!-- Gateway port -->
		<arg>UINT8_ARRAY</arg> <!-- 二Ary stream, and specifically by the developers to resolve -->
	</Client::onLoginSuccessfully>

	<Client::onLoginFailed>
		<id>503</id>
		<descr>Client login to loginapp, the server returns a failure.</descr>
		<arg>UINT16</arg> <!-- Error code MERCURY_ERR_SRV_NO_READY:server not ready,
			MERCURY_ERR_SRV_OVERLOAD:the server is under heavy load,
			MERCURY_ERR_NAME_PASSWORD:username or password is incorrect -->

		<arg>UINT8_ARRAY</arg> <!-- 二Ary stream, and specifically by the developers to resolve -->
	</Client::onLoginFailed>

	<Client::onCreatedProxies>
		<id>504</id>
		<descr>		The server has been created a associated with the client of the proxy Entity
				When logging in can also be the expression of the success callback。</descr>
	   <arg>UINT64</arg> <!-- With the entity associated to the short connection identification of the guid code -->
	   <arg>INT32</arg> <!-- entityID -->
	   <arg>STRING</arg> <!-- Script type -->
	</Client::onCreatedProxies>

	<Client::onCreatedEntity>
		<id>513</id>
		<descr>	The server has been created a associated with the client of the proxy Entity
				When logging in can also be the expression of the success callback.</descr>
	   <arg>INT32</arg> <!-- entityID -->
	   <arg>STRING</arg> <!-- Script type -->
	</Client::onCreatedEntity>

	<Client::onLoginBaseappFailed>
		<id>505</id>
		<descr>Client login to the gateway, the server returned a failure.</descr>
		<arg>UINT16</arg> <!-- Error code MERCURY_ERR_SRV_NO_READY:server not ready,
			MERCURY_ERR_ILLEGAL_LOGIN:illegal login,
			MERCURY_ERR_NAME_PASSWORD:username or password is incorrect -->
	</Client::onLoginBaseappFailed>

	<Client::onRemoteMethodCall>
		<id>506</id>
		<descr>Call a remote method.</descr>
		<arg>INT32</arg> <!-- entityID -->
		<arg>UINT16</arg> <!-- Method ID -->
		<arg>UINT8_ARRAY</arg> <!-- Method parameters binary stream, in particular by the method to parse the -->
	</Client::onRemoteMethodCall>

	<Client::onEntityEnterWorld>
		<id>507</id>
		<descr>One entity into the world(initial login when you first enter the world of their own this ENTITY,
			the subsequent theory is the other entity, the comparison of ID to judgment).
When the entity enters a player's View will trigger the client to this interface.
		(View: area of interest, can also be understood as Server visual range)
		</descr>
		<arg>INT32</arg> <!-- Enter the world of the entityID int32 -->
		<arg>UINT32</arg> <!-- spaceID uint32 -->
	</Client::onEntityEnterWorld>

	<Client::onEntityLeaveWorld>
		<id>508</id>
		<descr>One entity into the world(initial login when you first enter the world of their own this ENTITY,
			the subsequent theory is the other entity, the comparison of ID to judgment).
			When a entity leaves the player's View will trigger the client to this interface.
		</descr>
		<arg>INT32</arg> <!-- Enter the world of the entityID int32 -->
		<arg>UINT32</arg> <!-- spaceID uint32 -->
	</Client::onEntityLeaveWorld>

	<Client::onEntityEnterSpace>
		<id>509</id>
		<descr>One entity into the world(initial login when you first enter the world of their own this ENTITY,
			the subsequent theory is the other entity, the comparison of ID to judgment).
			When the entity enters a player's View will trigger the client to this interface.
			(View: area of interest, can also be understood as Server visual range)
		</descr>
		<arg>UINT32</arg> <!-- A scene ID uint32-->
		<arg>INT32</arg> <!-- Enter the world of the entityID int32 -->
	</Client::onEntityEnterSpace>

	<Client::onEntityLeaveSpace>
		<id>510</id>
		<descr>One entity into the world(initial login when you first enter the world of their own this ENTITY, the subsequent theory is the other entity, the comparison of ID to judgment).
When a entity leaves the player's View will trigger the client to this interface.
		</descr>
		<arg>UINT32</arg> <!-- A scene ID uint32-->
		<arg>INT32</arg> <!-- Enter the world of the entityID int32 -->
	</Client::onEntityLeaveSpace>

	<Client::onUpdatePropertys>
		<id>511</id>
		<descr>An entity attribute is updated.
		</descr>
		<arg>INT32</arg> <!-- entityID int32 -->
		<arg>UINT8_ARRAY</arg> <!-- Property update package, you need to understand析 -->
	</Client::onUpdatePropertys>

	<Client::onEntityDestroyed>
		<id>512</id>
		<descr>Tell the client of an entity of destruction, this entity is usually also not onEntityEnterWorld it.</descr>
		<arg>INT32</arg> <!-- entityID int32 -->
	</Client::onEntityDestroyed>

	<Client::onStreamDataStarted>
		<id>514</id>
		<descr>The server tells the client the data stream to start the download.
		</descr>
		<arg>INT16</arg> <!-- A download handle INT16 -->
		<arg>STRING</arg> <!-- Description -->
	</Client::onStreamDataStarted>

	<Client::onStreamDataRecv>
		<id>515</id>
		<descr>The client receives the data stream.
		</descr>
		<arg>INT16</arg> <!-- A download handle INT16 -->
		<arg>UINT32</arg> <!-- The present times the received data size -->
		<arg>UINT8_ARRAY</arg> <!-- Binary stream -->
	</Client::onStreamDataRecv>

	<Client::onStreamDataCompleted>
		<id>516</id>
		<descr>The server tells the client the data stream the download is complete.
		</descr>
		<arg>INT16</arg> <!-- A download handle INT16 -->
	</Client::onStreamDataCompleted>

	<Client::onKicked>
		<id>517</id>
		<descr>The server has been kicked out of the client.
		</descr>
		<arg>UINT16</arg> <!-- Error code mercury_errors.xml -->
	</Client::onKicked>

	<Client::onImportClientMessages>
		<id>518</id>
		<descr>Server returned Protocol packets.
		</descr>
		<arg>UINT8_ARRAY</arg> <!-- Need to parse -->
	</Client::onImportClientMessages>

	<Client::onImportClientEntityDef>
		<id>519</id>
		<descr>The server returns the entitydef data.
		</descr>
		<arg>UINT8_ARRAY</arg> <!-- Need to parse -->
	</Client::onImportClientEntityDef>

	<Client::addSpaceGeometryMapping>
		<id>520</id>
		<descr>The server to the client to add the geometric mapping.
		</descr>
		<arg>UINT32</arg> <!-- spaceID -->
		<arg>STRING</arg> <!-- respath -->
	</Client::addSpaceGeometryMapping>

	<Client::onHelloCB>
		<id>521</id>
		<descr>hello the callback.</descr>
	</Client::onHelloCB>

	<Client::onScriptVersionNotMatch>
		<id>522</id>
		<descr>The script version does not match.</descr>
	</Client::onScriptVersionNotMatch>

	<Client::onVersionNotMatch>
		<id>523</id>
		<descr>Engine version does not match.</descr>
	</Client::onVersionNotMatch>

	<Client::onControlEntity>
		<id>524</id>
		<descr>Tell the player: you currently control who of the displacement of the synchronization.</descr>
		<arg>INT32</arg> <!-- entityID int32 -->
		<arg>INT8</arg> <!-- 0 Cancellation control, 1 Start Control -->
	</Client::onControlEntity>

	<Logger::onAppActiveTick>
		<id>701</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Logger::onAppActiveTick>

	<Logger::registerLogWatcher>
		<id>702</id>
		<descr>Register a watcher.</descr>
		<arg>INT32</arg>   <!-- uid -->
		<arg>UINT32</arg>  <!-- logtypes filter -->
		<arg>INT32</arg>   <!-- globalOrder -->
		<arg>INT32</arg>   <!-- groupOrder -->
		<arg>STRING</arg>  <!-- date -->
		<arg>STRING</arg>  <!-- keyStr -->
		<arg>UINT8_ARRAY</arg>  <!-- component type filter -->
		<arg>UINT8</arg>   <!-- isfind -->
		<arg>UINT8</arg>   <!-- first -->
	</Logger::registerLogWatcher>

	<Logger::deregisterLogWatcher>
		<id>703</id>
		<descr>Unregister a watcher.</descr>
	</Logger::deregisterLogWatcher>

	<Logger::writeLog>
		<id>704</id>
		<descr>The logger sends a log.</descr>
		<arg>INT32</arg>   <!-- uid -->
		<arg>UINT32</arg>  <!-- logtype -->
		<arg>INT32</arg>   <!-- componentType -->
		<arg>UINT64</arg>  <!-- componentID -->
		<arg>INT32</arg>   <!-- globalOrder -->
		<arg>INT32</arg>   <!-- groupOrder -->
		<arg>INT64</arg>   <!-- time -->
		<arg>UINT32</arg>  <!-- ourotime -->
		<arg>BLOB</arg>    <!-- log size and msg -->
	</Logger::writeLog>

	<Property::position>
		<id>40000</id>
		<descr>Location of the property.</descr>
		<arg>VECTOR3</arg> <!-- float(x) float(y) float(z) -->
	</Property::position>

	<Property::direction>
		<id>40001</id>
		<descr>The direction attribute.</descr>
		<arg>VECTOR3</arg> <!-- float(roll) float(pitch) float(yaw) -->
	</Property::direction>

	<Property::spaceID>
		<id>40002</id>
		<descr>Where the space ID.</descr>
		<arg>SPACE_ID</arg> <!-- uint32 -->
	</Property::spaceID>



	<Baseapp::queryWatcher>
		<id>41001</id>
		<descr>watcher data query</descr>
	</Baseapp::queryWatcher>

	<Cellapp::queryWatcher>
		<id>41002</id>
		<descr>watcher data query</descr>
	</Cellapp::queryWatcher>

	<Loginapp::queryWatcher>
		<id>41003</id>
		<descr>watcher data query</descr>
	</Loginapp::queryWatcher>

	<Baseappmgr::queryWatcher>
		<id>41004</id>
		<descr>watcher data query</descr>
	</Baseappmgr::queryWatcher>

	<Cellappmgr::queryWatcher>
		<id>41005</id>
		<descr>watcher data query</descr>
	</Cellappmgr::queryWatcher>

	<Dbmgr::queryWatcher>
		<id>41006</id>
		<descr>watcher data query</descr>
	</Dbmgr::queryWatcher>

	<Interfaces::queryWatcher>
		<id>41007</id>
		<descr>watcher data query</descr>
	</Interfaces::queryWatcher>

	<Logger::queryWatcher>
		<id>41008</id>
		<descr>watcher data query</descr>
	</Logger::queryWatcher>

	<Baseappmgr::queryAppsLoads>
		<id>50001</id>
		<descr>Baseappmgr Status query</descr>
	</Baseappmgr::queryAppsLoads>

	<Cellappmgr::queryAppsLoads>
		<id>50002</id>
		<descr>Cellappmgr Status query</descr>
	</Cellappmgr::queryAppsLoads>

	<Cellappmgr::querySpaces>
		<id>50003</id>
		<descr>Query SpaceViewer list</descr>
	</Cellappmgr::querySpaces>

	<Cellappmgr::setSpaceViewer>
		<id>50004</id>
		<descr>Query cellappmgr in the cell list</descr>
	</Cellappmgr::setSpaceViewer>

	<Cellapp::setSpaceViewer>
		<id>50005</id>
		<descr>Query cellapp in the cell list</descr>
	</Cellapp::setSpaceViewer>

	<Baseapp::onExecScriptCommand>
		<id>55001</id>
		<descr>console remote execution of python statements.</descr>
	</Baseapp::onExecScriptCommand>

	<Cellapp::onExecScriptCommand>
		<id>55002</id>
		<descr>console remote execution of python statements.</descr>
	</Cellapp::onExecScriptCommand>

	<Bots::onExecScriptCommand>
		<id>55003</id>
		<descr>console remote execution of python statements.</descr>
	</Bots::onExecScriptCommand>

	<Baseapp::onAppActiveTick>
		<id>55100</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Baseapp::onAppActiveTick>

	<Cellapp::onAppActiveTick>
		<id>55101</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Cellapp::onAppActiveTick>

	<Cellappmgr::onAppActiveTick>
		<id>55102</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Cellappmgr::onAppActiveTick>

	<Baseappmgr::onAppActiveTick>
		<id>55103</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Baseappmgr::onAppActiveTick>

	<Interfaces::onAppActiveTick>
		<id>55104</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Interfaces::onAppActiveTick>

	<Dbmgr::onAppActiveTick>
		<id>55105</id>
		<descr>心跳协议</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Dbmgr::onAppActiveTick>

	<Loginapp::onAppActiveTick>
		<id>55106</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Loginapp::onAppActiveTick>

	<Bots::onAppActiveTick>
		<id>55107</id>
		<descr>The heartbeat Protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Bots::onAppActiveTick>
</root>
