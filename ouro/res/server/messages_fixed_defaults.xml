<root>
	<!-- 
		Since the network protocol ID in Ouroboros is automatically generated by the system, it is difficult to interface with the server if it is not using the supporting SDK.
		So kbe provides a mechanism to allow users to customize the ID of the network protocol.
		This is easier to use in some cases (for example: the traditional protocol docking method will have a protocol table, the client matches the protocol in the protocol table and then parses)
		
		For details, please refer to: http://ouroboros.org/cn/docs/configuration/messages_fixed.html
	-->
	
	<Machine::onFindInterfaceAddr>
		<id>1</id>
		<descr> finds the component interface address. </descr>
	</Machine::onFindInterfaceAddr>

	<Machine::startserver>
		<id>2</id>
		<descr> starts the server. </descr>
	</Machine::startserver>
	
	<Machine::stopserver>
		<id>3</id>
		<descr> stops the server. </descr>
	</Machine::stopserver>
	
	<Machine::onQueryAllInterfaceInfos>
		<id>4</id>
		<descr>Query all interface information. </descr>
	</Machine::onQueryAllInterfaceInfos>

	<Machine::onQueryMachines>
		<id>5</id>
		<descr>Query all machine processes. </descr>
	</Machine::onQueryMachines>

	<Machine::killserver>
		<id>6</id>
		<descr>kills the server process. </descr>
	</Machine::killserver>

	<Loginapp::reqClose>
		<id>1</id>
		<descr> The client requested a disconnection. </descr>
	</Loginapp::reqClose>
	
	<Loginapp::reqCreateAccount>
		<id>2</id>
		<descr> The client requests to create an account. </descr>
		<arg>STRING</arg> <!-- Account Name -->
		<arg>STRING</arg> <!-- Password -->
		<arg>UINT8_ARRAY</arg> <!-- Binary stream, specifically parsed by the developer -->
	</Loginapp::reqCreateAccount>
	
	<Loginapp::login>
		<id>3</id>
		<descr> The client requests to log in to the loginapp process of the server. This process will return a gateway address after receiving the request for authentication. </descr>
		<arg>STRING</arg> <!-- Front End Category 0: Debug Front End, 1: Mobile Front End, n.. -->
		<arg>UINT8_ARRAY</arg> <!-- is specifically resolved by the developer -->
		<arg>STRING</arg> <!-- Account Name -->
		<arg>STRING</arg> <!-- Password -->
	</Loginapp::login>
	
	<Loginapp::hello>
		<id>4</id>
		<descr>hello。</descr>
	</Loginapp::hello>

	<Loginapp::importClientMessages>
		<id>5</id>
		<descr> The client requests to import the message protocol. </descr>
	</Loginapp::importClientMessages>
	
	<Loginapp::reqCreateMailAccount>
		<id>6</id>
		<descr> The client requests to create a mail account. </descr>
		<arg>STRING</arg> <!-- Account Name -->
		<arg>STRING</arg> <!-- Password -->
		<arg>UINT8_ARRAY</arg> <!-- Binary stream, specifically parsed by the developer -->
	</Loginapp::reqCreateMailAccount>
	
	<Loginapp::importClientSDK>
		<id>7</id>
		<descr>Client SDK export. </descr>
	</Loginapp::importClientSDK>
	
	<Baseapp::hello>
		<id>200</id>
		<descr>hello。</descr>
	</Baseapp::hello>
	
	<Baseapp::reqClose>
		<id>201</id>
		<descr> The client requested a disconnection. </descr>
	</Baseapp::reqClose>
	
	<Baseapp::loginBaseapp>
		<id>202</id>
		<descr> The client requests a gateway process to log in to the server, and if it is legitimate, it will enter the game. </descr>
		<arg>STRING</arg> <!-- Account Name -->
		<arg>STRING</arg> <!-- Password -->
	</Baseapp::loginBaseapp>
	
	<Baseapp::reloginBaseapp>
		<id>204</id>
		<descr>Re-login Quickly establish an interaction with the gateway (provided that you have logged in before,
			After disconnecting, the server can quickly establish a connection with the server and achieve the purpose of manipulating the entity if the server determines that the front-end Entity has not expired.
		</descr>
		<arg>UINT64</arg> <!-- 64-bit random GUID code -->
		<arg>INT32</arg> <!-- ENTITY_ID -->
	</Baseapp::reloginBaseapp>
	
	<Baseapp::onRemoteCallCellMethodFromClient>
		<id>205</id>
		<descr> calls a cell remote method. </descr>
		<arg>INT32</arg> <!-- entityID -->

		<arg>UINT8_ARRAY</arg> <!-- Method parameter binary stream, specifically parsed by method -->
	</Baseapp::onRemoteCallCellMethodFromClient>
	
	<Baseapp::onClientActiveTick>
		<id>206</id>
		<descr>Tick of the client. </descr>
	</Baseapp::onClientActiveTick>
	
	<Baseapp::importClientMessages>
		<id>207</id>
		<descr> The client requests to import the message protocol. </descr>
	</Baseapp::importClientMessages>

	<Baseapp::importClientEntityDef>
		<id>208</id>
		<descr> Client entitydef export. </descr>
	</Baseapp::importClientEntityDef>

	<Base::onRemoteMethodCall>
		<id>301</id>
		<descr> calls a base remote method. </descr>
		<arg>INT32</arg> <!-- entityID -->
		<arg>UINT16</arg> <!-- Method ID -->
		<arg>UINT8_ARRAY</arg> <!-- Method parameter binary stream, specifically parsed by method -->
	</Base::onRemoteMethodCall>
	
	<Entity::onRemoteMethodCall>
		<id>302</id>
		<descr> calls a cell remote method. </descr>
		<arg>INT32</arg> <!-- entityID -->
		<arg>UINT16</arg> <!-- Method ID -->
		<arg>UINT8_ARRAY</arg> <!-- Method parameter binary stream, specifically parsed by method -->
	</Entity::onRemoteMethodCall>
	
	<Proxy::onClientGetCell>
		<id>401</id>
		After the <descr> server initializes the cell information to the client, the client should inform the server of the callback for the server to determine.
		</descr>
	</Proxy::onClientGetCell>
	
	<Client::onCreateAccountResult>
		<id>501</id>
		<descr>Create account success and failure callbacks. </descr>
		<arg>UINT16</arg> <!-- Error code MERCURY_ERR_SRV_NO_READY: The server is not ready,
									MERCURY_ERR_ACCOUNT_CREATE: Creation failed (already exists),
									MERCURY_SUCCESS: Account creation was successful -->
		<arg>UINT8_ARRAY</arg> <!-- Binary stream, specifically parsed by the developer -->
	</Client::onCreateAccountResult>
	
	<Client::onLoginSuccessfully>
		<id>502</id>
		<descr> The client logs in to loginapp and the server returns successfully. </descr>
		<arg>STRING</arg> <!-- Internal account name -->
		<arg>STRING</arg> <!-- Gateway IP address -->
		<arg>UINT16</arg> <!-- Gateway Port -->
		<arg>UINT8_ARRAY</arg> <!-- Binary stream, specifically parsed by the developer -->
	</Client::onLoginSuccessfully>
	
	<Client::onLoginFailed>
		<id>503</id>
		<descr> The client logs in to loginapp and the server returns. </descr>
		<arg>UINT16</arg> <!-- Error code MERCURY_ERR_SRV_NO_READY: The server is not ready,
									MERCURY_ERR_SRV_OVERLOAD: The server is overloaded,
									MERCURY_ERR_NAME_PASSWORD: Username or password is incorrect -->
									
		<arg>UINT8_ARRAY</arg> <!-- Binary stream, specifically parsed by the developer -->
	</Client::onLoginFailed>
	
	<Client::onCreatedProxies>
		<id>504</id>
		<descr> The server has created a proxy Entity associated with the client.
	   A successful callback can also be expressed when logging in. </descr>
	   <arg>UINT64</arg> <!-- guid code associated with entity for short connection identity confirmation -->
	   <arg>INT32</arg> <!-- entityID -->
	   <arg>STRING</arg> <!-- Script Type -->
	</Client::onCreatedProxies>

	<Client::onCreatedEntity>
		<id>513</id>
		<descr> The server has created a proxy Entity associated with the client.
	   A successful callback can also be expressed when logging in. </descr>
	   <arg>INT32</arg> <!-- entityID -->
	   <arg>STRING</arg> <!-- Script Type -->
	</Client::onCreatedEntity>
	
	<Client::onLoginBaseappFailed>
		<id>505</id>
		<descr> The client logs in to the gateway and the server returns. </descr>
		<arg>UINT16</arg> <!-- Error code MERCURY_ERR_SRV_NO_READY: The server is not ready,
									MERCURY_ERR_ILLEGAL_LOGIN: illegal login,
									MERCURY_ERR_NAME_PASSWORD: Username or password is incorrect -->
	</Client::onLoginBaseappFailed>
	
	<Client::onRemoteMethodCall>
		<id>506</id>
		<descr> calls a remote method. </descr>
		<arg>INT32</arg> <!-- entityID -->
		<arg>UINT16</arg> <!-- Method ID -->
		<arg>UINT8_ARRAY</arg> <!-- Method parameter binary stream, specifically parsed by method -->
	</Client::onRemoteMethodCall>
	
	<Client::onEntityEnterWorld>
		<id>507</id>
		<descr>An entity enters the world (the first time you log in to the world is your own ENTITY, and then the theory is other entities, compared to the ID to judge).
			The client interface is triggered when an entity enters the player's View. (View: area of interest, also can be understood as the visual range on the server)
		</descr>
		<arg>INT32</arg> <!-- Enter the world's entityID int32 -->
		<arg>UINT32</arg> <!-- spaceID uint32 -->
	</Client::onEntityEnterWorld>
	
	<Client::onEntityLeaveWorld>
		<id>508</id>
		<descr>An entity enters the world (the first time you log in to the world is your own ENTITY, and then the theory is other entities, compared to the ID to judge).
			The client interface is triggered when an entity leaves the player's View.
		</descr>
		<arg>INT32</arg> <!-- Enter the world's entityID int32 -->
		<arg>UINT32</arg> <!-- spaceID uint32 -->
	</Client::onEntityLeaveWorld>

	<Client::onEntityEnterSpace>
		<id>509</id>
		<descr>An entity enters the world (the first time you log in to the world is your own ENTITY, and then the theory is other entities, compared to the ID to judge).
			The client interface is triggered when an entity enters the player's View. (View: area of interest, also can be understood as the visual range on the server)
		</descr>
		<arg>UINT32</arg> <!-- ID of a scene uint32-->
		<arg>INT32</arg> <!-- Enter the world's entityID int32 -->
	</Client::onEntityEnterSpace>
	
	<Client::onEntityLeaveSpace>
		<id>510</id>
		<descr>An entity enters the world (the first time you log in to the world is your own ENTITY, and then the theory is other entities, compared to the ID to judge).
			The client interface is triggered when an entity leaves the player's View.
		</descr>
		<arg>UINT32</arg> <!-- ID of a scene uint32-->
		<arg>INT32</arg> <!-- Enter the world's entityID int32 -->
	</Client::onEntityLeaveSpace>
	
	<Client::onUpdatePropertys>
		<id>511</id>
		<descr>The attribute of an entity is updated.
		</descr>
		<arg>INT32</arg> <!-- entityID int32 -->
		<arg>UINT8_ARRAY</arg> <!-- Property update package, need to be parsed -->
	</Client::onUpdatePropertys>
	
	<Client::onEntityDestroyed>
		<id>512</id>
		<descr> tells the client that an entity has been destroyed. This type of entity is usually not onEntityEnterWorld. </descr>
		<arg>INT32</arg> <!-- entityID int32 -->
	</Client::onEntityDestroyed>
	
	<Client::onStreamDataStarted>
		<id>514</id>
		The <descr> server tells the client that the data stream starts downloading.
		</descr>
		<arg>INT16</arg> <!-- A download handle INT16 -->
		<arg>STRING</arg> <!-- Description -->
	</Client::onStreamDataStarted>
	
	<Client::onStreamDataRecv>
		<id>515</id>
		<descr> The client receives the data stream.
		</descr>
		<arg>INT16</arg> <!-- A download handle INT16 -->
		<arg>UINT32</arg> <!-- The size of the data received this time -->
		<arg>UINT8_ARRAY</arg> <!-- Binary stream -->
	</Client::onStreamDataRecv>
	
	<Client::onStreamDataCompleted>
		<id>516</id>
		The <descr> server informs the client that the data stream download is complete.
		</descr>
		<arg>INT16</arg> <!-- A download handle INT16 -->
	</Client::onStreamDataCompleted>
	
	<Client::onKicked>
		<id>517</id>
		<descr> The server has kicked out the client.
		</descr>
		<arg>UINT16</arg> <!-- Error code mercury_errors.xml -->
	</Client::onKicked>

	<Client::onImportClientMessages>
		<id>518</id>
		<descr> The protocol packet returned by the server.
		</descr>
		<arg>UINT8_ARRAY</arg> <!-- Need to parse -->
	</Client::onImportClientMessages>

	<Client::onImportClientEntityDef>
		<id>519</id>
		<descr> The entitydef data returned by the server.
		</descr>
		<arg>UINT8_ARRAY</arg> <!-- Need to parse -->
	</Client::onImportClientEntityDef>

	<Client::addSpaceGeometryMapping>
		<id>520</id>
		The <descr> server adds a geometric map to the client.
		</descr>
		<arg>UINT32</arg> <!-- spaceID -->
		<arg>STRING</arg> <!-- respath -->
	</Client::addSpaceGeometryMapping>
	
	<Client::onHelloCB>
		<id>521</id>
		<descr>hello callback. </descr>
	</Client::onHelloCB>
	
	<Client::onScriptVersionNotMatch>
		<id>522</id>
		The <descr> script version does not match. </descr>
	</Client::onScriptVersionNotMatch>
	
	<Client::onVersionNotMatch>
		<id>523</id>
		The <descr> engine version does not match. </descr>
	</Client::onVersionNotMatch>

	<Client::onControlEntity>
		<id>524</id>
		<descr> tells the player: who is currently controlling who's displacement is synchronized. </descr>
		<arg>INT32</arg> <!-- entityID int32 -->
		<arg>INT8</arg> <!-- 0 Cancel control, 1 start control -->
	</Client::onControlEntity>
	
	<Logger::onAppActiveTick>
		<id>701</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Logger::onAppActiveTick>

	<Logger::registerLogWatcher>
		<id>702</id>
		<descr>Register a watcher. </descr>
		<arg>INT32</arg>   <!-- uid -->
		<arg>UINT32</arg>  <!-- logtypes filter -->
		<arg>INT32</arg>   <!-- globalOrder -->
		<arg>INT32</arg>   <!-- groupOrder -->
		<arg>STRING</arg>  <!-- date -->
		<arg>STRING</arg>  <!-- keyStr -->
		<arg>UINT8_ARRAY</arg>  <!-- component type filter -->
		<arg>UINT8</arg>   <!-- isfind -->
		<arg>UINT8</arg>   <!-- first -->
	</Logger::registerLogWatcher>
	
	<Logger::deregisterLogWatcher>
		<id>703</id>
		<descr> Unregister a watcher. </descr>
	</Logger::deregisterLogWatcher>

	<Logger::writeLog>
		<id>704</id>
		<descr> sends a log to the logger. </descr>
		<arg>INT32</arg>   <!-- uid -->
		<arg>UINT32</arg>  <!-- logtype -->
		<arg>INT32</arg>   <!-- componentType -->
		<arg>UINT64</arg>  <!-- componentID -->
		<arg>INT32</arg>   <!-- globalOrder -->
		<arg>INT32</arg>   <!-- groupOrder -->
		<arg>INT64</arg>   <!-- time -->
		<arg>UINT32</arg>  <!-- kbetime -->
		<arg>BLOB</arg>    <!-- log size and msg -->
	</Logger::writeLog>

	<Property::position>
		<id>40000</id>
		<descr> location attribute. </descr>
		<arg>VECTOR3</arg> <!-- float(x) float(y) float(z) -->
	</Property::position>

	<Property::direction>
		<id>40001</id>
		<descr> direction attribute. </descr>
		<arg>VECTOR3</arg> <!-- float(roll) float(pitch) float(yaw) -->
	</Property::direction>
	
	<Property::spaceID>
		<id>40002</id>
		<descr> The space ID. </descr>
		<arg>SPACE_ID</arg> <!-- uint32 -->
	</Property::spaceID>



	<Baseapp::queryWatcher>
		<id>41001</id>
		<descr>watcher data query</descr>
	</Baseapp::queryWatcher>

	<Cellapp::queryWatcher>
		<id>41002</id>
		<descr>watcher data query</descr>
	</Cellapp::queryWatcher>

	<Loginapp::queryWatcher>
		<id>41003</id>
		<descr>watcher data query</descr>
	</Loginapp::queryWatcher>

	<Baseappmgr::queryWatcher>
		<id>41004</id>
		<descr>watcher data query</descr>
	</Baseappmgr::queryWatcher>

	<Cellappmgr::queryWatcher>
		<id>41005</id>
		<descr>watcher data query</descr>
	</Cellappmgr::queryWatcher>

	<Dbmgr::queryWatcher>
		<id>41006</id>
		<descr>watcher data query</descr>
	</Dbmgr::queryWatcher>

	<Interfaces::queryWatcher>
		<id>41007</id>
		<descr>watcher data query</descr>
	</Interfaces::queryWatcher>

	<Logger::queryWatcher>
		<id>41008</id>
		<descr>watcher data query</descr>
	</Logger::queryWatcher>
	
	<Baseappmgr::queryAppsLoads>
		<id>50001</id>
		<descr>Baseappmgr status query</descr>
	</Baseappmgr::queryAppsLoads>

	<Cellappmgr::queryAppsLoads>
		<id>50002</id>
		<descr>Cellappmgr Status Query</descr>
	</Cellappmgr::queryAppsLoads>

	<Cellappmgr::querySpaces>
		<id>50003</id>
		<descr>Query the SpaceViewer list</descr>
	</Cellappmgr::querySpaces>

	<Cellappmgr::setSpaceViewer>
		<id>50004</id>
		<descr>Query the list of cells in cellappmgr</descr>
	</Cellappmgr::setSpaceViewer>

	<Cellapp::setSpaceViewer>
		<id>50005</id>
		<descr>Query the list of cells in cellapp</descr>
	</Cellapp::setSpaceViewer>

	<Baseapp::onExecScriptCommand>
		<id>55001</id>
		<descr>console remotely executes python statements. </descr>
	</Baseapp::onExecScriptCommand>

	<Cellapp::onExecScriptCommand>
		<id>55002</id>
		<descr>console remotely executes python statements. </descr>
	</Cellapp::onExecScriptCommand>

	<Bots::onExecScriptCommand>
		<id>55003</id>
		<descr>console remotely executes python statements. </descr>
	</Bots::onExecScriptCommand>

	<Baseapp::onAppActiveTick>
		<id>55100</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Baseapp::onAppActiveTick>

	<Cellapp::onAppActiveTick>
		<id>55101</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Cellapp::onAppActiveTick>

	<Cellappmgr::onAppActiveTick>
		<id>55102</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Cellappmgr::onAppActiveTick>

	<Baseappmgr::onAppActiveTick>
		<id>55103</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Baseappmgr::onAppActiveTick>

	<Interfaces::onAppActiveTick>
		<id>55104</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Interfaces::onAppActiveTick>

	<Dbmgr::onAppActiveTick>
		<id>55105</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Dbmgr::onAppActiveTick>

	<Loginapp::onAppActiveTick>
		<id>55106</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Loginapp::onAppActiveTick>

	<Bots::onAppActiveTick>
		<id>55107</id>
		<descr>heartbeat protocol</descr>
		<arg>INT32</arg>   <!-- COMPONENT_TYPE -->
		<arg>UINT64</arg> <!-- COMPONENT_ID -->
	</Bots::onAppActiveTick>
</root>
