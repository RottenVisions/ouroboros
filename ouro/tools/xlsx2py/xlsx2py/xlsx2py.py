# -*- coding: gb2312 -*-
import sys
import re
import os
import string
import signal
import time
import codecs
import json

from ExcelTool import ExcelTool
from config import *
import functions
try:
	import character
except:
	character = functions
import xlsxtool
import xlsxError
import copy

SYS_CODE = sys.getdefaultencoding()

def siginit(sigNum, sigHandler):
	print("byebye")
	sys.exit(1)

Signal.signal(signal.SIGINT, siginit) #Ctrl-c

def hasFunc(funcName):
	return hasattr(character, funcName) or hasattr(functions, funcName)

def getFunc(funcName):
	if hasattr(character, funcName):
		return getattr(character, funcName)
	return getattr(functions, funcName)

g_dctDatas = {}
g_fdatas = {}

class xlsx2py(object):
	"""
	Export excel data as a py file. The process requires code conversion.
	"""
	def __init__(self, infile, outfile):
		Sys.excepthook = xlsxError.except_hook #traceback processing, hope to output Chinese
		Self.infile = os.path.abspath(infile) #temporary excel filename
				self.outfile = os.path.abspath(outfile)						#data文件名
		return

	def __initXlsx(self):
		self.xbook = ExcelTool(self.infile)

		while not self.xbook.getWorkbook(forcedClose = True):
			xlsxtool.exportMenu(EXPORT_INFO_RTEXCEL, OCallback = self.resetXlsx)

	def resetXlsx(self):
		"""
		Enter the callback of O(other)
		Close open excel and reopen
		"""
		self.xbook.getWorkbook(forcedClose = True)

	def __initInfo(self):
		Self.__exportSheetIndex = [] #Store index of the guidetable
		self.headerDict = {} #export table first line into dictionary
		self.mapDict = {} #Generate the dictionary generated by the table (the first line is the negation of the table description)

#####################Executive theme################################
	def run(self):
		"""
		Column data with $ needs a pair table, first generate a pair dictionary
		"""
		Self.__initXlsx() #initial excel related
		Self.__initInfo() #initial guide related
		self.openFile()
		self.sth4Nth() #Go to the next stage
		self.constructMapDict() #Generate the dictionary
		self.__onRun()

	def __onRun(self):
		self.writeLines = 0 #record the number of rows of excel that have been written
		self.parseDefineLine() #analysis file

###############Searching for table and tag import table##################
	def sth4Nth(self):
		"""
		Something for nothing, need to have a table and import table
		"""
		for index in range(1, self.xbook.getSheetCount() + 1):
			sheetName = self.xbook.getSheetNameByIndex(index)
			if sheetName == EXPORT_MAP_SHEET:
				self.__onFindMapSheet(index)
			if sheetName.startswith(EXPORT_PREFIX_CHAR):
				self.__onFindExportSheet(index)
		self.onSth4Nth()

	def onSth4Nth(self):
		"""
		"""
		if not hasattr(self, 'mapIndex'):
			self.xlsxClear(EXPORT_ERROR_NOMAP)

		if len(self.__exportSheetIndex) == 0:
			xlsxError.error_input(EXPORT_ERROR_NOSHEET)

		return

	def __onFindMapSheet(self, mapIndex):
		self.mapIndex = mapIndex
		return

	def __onFindExportSheet(self, Eindex):
		"""
		Finished
		"""
		self.__exportSheetIndex.append(Eindex)

	def constructMapDict(self):
		"""
		Generate a pair dictionary, only one pair table
		"""
		mapDict = {}
		sheet = self.xbook.getSheetByIndex(self.mapIndex)
		if not sheet:
			return

		for col in range(0, self.xbook.getRowCount(self.mapIndex)):
			colValues = self.xbook.getColValues(sheet, col)
			if colValues:
				for v in  [e for e in colValues[1:] if e[0] and isinstance(e[0], str) and e[0].strip()]:
					print (v)
					mapStr = v[0].replace(':', ":") #中文":" and ":"
					try:
						k, v  = mapStr.split(":")
						k = str.strip(k)
						v = str.strip(v)
						mapDict[k] = v
					except Exception as errstr:
						Print( "waring: need to check the pair table %d column, err=%s"%(col, errstr))
		self.__onConstruct(mapDict)
		return

	def __onConstruct(self, mapDict):
		"""
		The generation of the dictionary is completed.
		"""
		self.mapDict = mapDict
		return

#####################头头检测#############################################
	def parseDefineLine(self):
		Self.__checkDefine() #Check if the definition is correct
		Self.__checkData() #Check if the data meets the rules

	def __reCheck(self, head):
		pattern = "(\w+)(\[.*])(\[\w+\])"
		reGroups =re.compile(pattern).match(head)

		if not reGroups:
			return ()
		return reGroups.groups()

	def __convertKeyName(self, name):
		try:
			tname = eval(name)
		except:
			pass
		else:
			if type(tname) == int or type(tname) == float:
				return tname

		return name

	def __checkDefine(self):
		"""
		Whether the elements of the first line conform to the defined format "name[signs][func]" and whether the key meets the requirements
		"""
		Print( "Check if the file header (first line) is correct")
		for index in self.__exportSheetIndex:
			self.sheetKeys = []
			headList = self.xbook.getRowValues(self.xbook.getSheetByIndex(index), EXPORT_DEFINE_ROW -1 )
			enName = [] #check named duplicate temporary variables
			reTuples = []

			self.headerDict[index] = {}
			for c, head in enumerate(headList):
				If head is None or head.strip() == '': #Export the first row of the table, then this column will be ignored
					self.__onCheckSheetHeader(self.headerDict[index], c, None)
					continue

				reTuple = self.__reCheck(head)

				If len(reTuple) == 3: #defined is split into three parts: name, signs, func, signs can be empty
					name, signs, funcName = reTuple[0], reTuple[1][1:-1], reTuple[2][1:-1]
					name = self.__convertKeyName(name)
					For s in signs: #symbol definition is within the rules
						if s not in EXPORT_ALL_SIGNS:
							self.xlsxClear(EXPORT_ERROR_NOSIGN, (EXPORT_DEFINE_ROW, c+1))

					If EXPORT_SIGN_GTH in signs: #是为key
						self.sheetKeys.append(c)

					If len(self.sheetKeys) > EXPORT_KEY_NUMS: #key exceeds the specified number
						self.xlsxClear(EXPORT_ERROR_NUMKEY, (EXPORT_DEFINE_ROW, c+1))

					If name not in enName: #name cannot be repeated
						enName.append(name)
					else:
						self.xlsxClear(EXPORT_ERROR_REPEAT, \
						(self.xbook.getSheetNameByIndex(index).encode(FILE_CODE), EXPORT_DEFINE_ROW, c+1))

					If not hasFunc(funcName): #funcName is there?
						self.xlsxClear(EXPORT_ERROR_NOFUNC, (xlsxtool.toGBK(funcName), c+1))

				else:
					self.xlsxClear(EXPORT_ERROR_HEADER, (self.xbook.getSheetNameByIndex(index).encode(FILE_CODE), EXPORT_DEFINE_ROW, c+1))

				Self.__onCheckSheetHeader(self.headerDict[index], c, (name, signs, funcName)) # Define a line that is often used to save it.

			self.__onCheckDefine()

		return

	def __onCheckSheetHeader(self, DataDict, col, headerInfo):
		DataDict[col] = headerInfo

	def __onCheckDefine(self):
		If len(self.sheetKeys) != EXPORT_KEY_NUMS: #key can't be less
			self.xlsxClear(EXPORT_ERROR_NOKEY, ("requires %d and only %d"%(EXPORT_KEY_NUMS,len(self.sheetKeys))))

		Print( "The header is detected correctly", time.ctime(time.time()) )

	def sheetIndex2Data(self):
		self.sheet2Data = {}
		for index in self.__exportSheetIndex:
			SheetName = self.xbook.getSheetNameByIndex(index)
			sheetName = SheetName[SheetName.find(EXPORT_PREFIX_CHAR)+1:]
			if sheetName in self.mapDict:
				dataName = self.mapDict[sheetName]
				if dataName in self.sheet2Data:
					self.sheet2Data[dataName].append(index)
				else:
					self.sheet2Data[dataName] =  [index]

	def __checkData(self):
		"""
		Whether the column data conforms to the naming convention, generating the required dictionary
		"""
		self.sheetIndex2Data()
		self.dctDatas = g_dctDatas
		self.hasExportedSheet = []

		for dataName, indexList  in self.sheet2Data.items():
			self.curIndexMax = len(indexList)
			self.curProIndex = []
			for index in indexList:
				sheet = self.xbook.getSheetByIndex(index)
				self.curProIndex.append(index)

				cols =  self.xbook.getRowCount(index)
				rows  = self.xbook.getColCount(index)
				if dataName not in self.dctDatas:
					self.dctDatas[dataName] = {}
				self.dctData = self.dctDatas[dataName]

				for row in range(3,  rows + 1):
					rowval = self.xbook.getRowValues(sheet, row - 1)
					childDict = {}
					for col in range(1, cols + 1):
						val = rowval[col - 1]
						if val != None:
							val = (str(rowval[col - 1]),)
						else:
							val = ("",)
						#val = (self.xbook.getText(sheet, row, col),)
						if self.headerDict[index][col-1] is None:
							continue

						name, sign, funcName = self.headerDict[index][col-1]
						if '$' in sign and len(val[0]) > 0:
							self.needReplace({'v':val[0], "pos":(row, col)})
							v = self.mapDict[xlsxtool.GTOUC(xlsxtool.val2Str(val[0]))] #mapDict:key is unicode.key must be converted to unicode
						else:
							v = val[0]
						if EXPORT_SIGN_DOT in sign and v is None:
							self.xlsxClear(EXPORT_ERROR_NOTNULL, (col, row))

						try:
							sv = v#xlsxtool.toGBK(v)
						except:
							sv = v

						func = getFunc(funcName)

						try:
							v = func(self.mapDict, self.dctData, childDict, sv)
						except Exception as errstr:
							self.xlsxClear(EXPORT_ERROR_FUNC, (errstr, funcName, sv, row, col))
							
						for ss in sign.replace('$',''):
							EXPORT_SIGN[ss](self,{"v":v,"pos":(row, col)})

						#if isinstance(v, (isinstance, unicode)):
						#	try:
						#		v = v.decode("gb2312").encode("utf-8")
						#	except:
						#		pass
						childDict[name] = v

										print( "当前:%i/%i" % (row, rows) )
					self.dctData[self.tempKeys[-1]] = copy.deepcopy(childDict)

				self.writeHead()

			overFunc = self.mapDict.get('overFunc')
			if overFunc is not None:
				func = getFunc(overFunc)
				self.dctData = func(self.mapDict, self.dctDatas, self.dctData, dataName)
				self.dctDatas[dataName] = self.dctData
			
			g_dctDatas.update(self.dctDatas)
			self.__onCheckSheet()
			
		self.__onCheckData()
		self.writeFoot()

	def __onCheckSheet(self):
		if hasattr(self, "tempKeys"):
			del self.tempKeys
		return

	def __onCheckData(self):
		self.exportSheet()

############## Symbol dictionary related settings EXPORT_SIGN##################
	def isNotEmpty(self, cellData):
		if cellData['v'] is None:
			self.xlsxClear(EXPORT_ERROR_NOTNULL, (cellData['pos'], ))

	def needReplace(self, cellData):
		"""macro replacement"""
		v = cellData["v"].strip()

		If isinstance(v, float): # Prevent digital error (1:string) mapDict is a unicode string
			v = str(int(v))

		If v not in self.mapDict: #detect without replacing
			self.xlsxClear(EXPORT_ERROR_NOTMAP, (cellData['pos'], v))

	def isKey(self, cellData):
		if not hasattr(self, "tempKeys"):
			self.tempKeys = []

		if cellData['v'] not in self.tempKeys:
			self.tempKeys.append(cellData['v'])
		else:
			self.xlsxClear(EXPORT_ERROR_REPKEY, (cellData['pos'], \
				(self.tempKeys.index(cellData['v'])+3, cellData['pos'][1] ), cellData['v']) )




###############export to py part#####################################
	def exportSheet(self):
		"""
		Export
		"""
		self.__onExportSheet()
		return

	def __onExportSheet(self):
		"""
		Data into py file
		"""
		self.writeXLSX2PY()
		return

	def openFile(self):
		"""
		File directory creation
		"""
		dirPath = os.path.split(self.outfile)[0]

		if not os.path.isdir(dirPath):
			try:
				xlsxtool.createDir(dirPath)
			except:
				self.xlsxClear(EXPORT_ERROR_CPATH, (dirPath, ))
		try:
			fileHandler = codecs.open(self.outfile, "w+",'utf-8')
			#fileHandler = open(self.outfile, "w+")
		except:
			self.xlsxClear(EXPORT_ERROR_FILEOPEN, (self.outfile, ))

		Self.__onOpenFile(fileHandler) #Directory created successfully, file open
		return

	def __onOpenFile(self,  fileHandler):
		"""
		The py file is open and you can write the file.
		"""
		self.fileName = self.outfile
		self.fileHandler = fileHandler
		del self.outfile

	def xlsxWrite(self, stream):
		"""
		Write data file
		"""
		if not hasattr(self, "fileHandler"):
			self.xlsxClear(EXPORT_ERROR_FILEOPEN, ())
		try:
			self.fileHandler.write(stream)
		except Exception as errstr:
			self.xlsxClear(EXPORT_ERROR_IOOP, (errstr))

	def writeXLSX2PY(self):
		"""
		The first few lines of text
		"""
		self.writeBody()
		return

	def writeHead(self):
		Print( "Start writing to file:", time.ctime(time.time()) )
		try:
			SheetName = self.xbook.getSheetNameByIndex(self.curProIndex[-1])
		except:
			Print( "Get the name of the table error")

		sheetName = SheetName[SheetName.find(EXPORT_PREFIX_CHAR)+1:]
		if sheetName in self.mapDict:
			dataName = self.mapDict[sheetName]
			self.hasExportedSheet.append(self.curProIndex[-1])
		else:
			self.xlsxClear(2, (sheetName.encode(FILE_CODE),))

		stream  = ""
		dataFileInfo = (self.infile + '.' + SheetName).encode("UTF-8")

		if len(self.hasExportedSheet) <= 1:
			stream =  EXPORT_DATA_HEAD
			globalDefs = self.mapDict.get('globalDefs', '')
			if len(globalDefs) > 0:
				func = getFunc(globalDefs)
				globalDefs = func(self.dctData)
				if len(globalDefs) > 0:
					globalDefs += "\n"
					if "globalDefs" in g_fdatas:
						g_fdatas["globalDefs"] += globalDefs
					else:
						g_fdatas["globalDefs"] = globalDefs


	def writeBody(self):
		#for index  in self.curProIndex:
		#	xlsxError.info_input(EXPORT_INFO_ING, (self.xbook.getSheetNameByIndex(index).encode(FILE_CODE), ))
		self.xlsxWrite(EXPORT_DATA_HEAD)
		if "globalDefs" in g_fdatas:
			self.xlsxWrite(g_fdatas["globalDefs"])

		for dataName, datas in g_dctDatas.items():
			stream = dataName + "="
			#stream += xlsxtool.dict_to_text(datas) + "\n"
			stream += "%s\n" % (datas)
			self.xlsxWrite(stream)
			jsonhandle = codecs.open(self.fileHandler.stream.name + "." + dataName + ".json", "w+",'utf-8')
			s = json.dumps(datas)
			jsonhandle.write("{%s}" % (s[1:-1]))
			jsonhandle.close()
			
	def writeFoot(self):
		"""
		File tail
		"""
		if len(self.hasExportedSheet) < len(self.__exportSheetIndex):
			return

		allDataDefs = self.mapDict.get('allDataDefs', '')
		if len(allDataDefs) > 0:
			func = getFunc(allDataDefs)
			allDataDefs = func(self.dctData)
			if "allDataDefs" in g_fdatas:
					g_fdatas["allDataDefs"] += allDataDefs
			else:
					g_fdatas["allDataDefs"] = allDataDefs

		stream = "\nallDatas = {\n"
		for dataName, indexList in self.sheet2Data.items():
			for index in indexList:
				SheetName = self.xbook.getSheetNameByIndex(index)
				sheetName = SheetName[SheetName.find(EXPORT_PREFIX_CHAR)+1:]
				stream += "\t'" +  sheetName
				stream += "':"
				stream += dataName
				stream += ",\n"

		if len(allDataDefs) > 0:
			stream += "\t" + g_fdatas["allDataDefs"] + ",\n"

		stream +="}"
		self.xlsxWrite(stream)
		self.xlsxbyebye()
		Print( "Write time:", time.ctime(time.time()) )

##############other##################
	def xlsxClose(self):
		"""
		Close document
		"""
		if hasattr(self, "fileHandler"):
			self.fileHandler.close()

		self.xbook.close()
		return

	def xlsxClear(self, errno = 0, msg = ''):
		"""
		The program quits abnormally and cleans up the open Excel
		"""
		self.xlsxClose()
		if errno > 0:
			raise xlsxError.xe(errno, msg)
		else:
			sys.exit(1)

	def xlsxbyebye(self):
		"""
		Normal exit
		"""
		self.xlsxClose()
		return

	def getSheetsCounts(self):
		return reduce(lambda x,y:x+y, \
			[self.xbook.getColCount(index) for index in self.__exportSheetIndex])

EXPORT_SIGN['.'] = xlsx2py.isNotEmpty
EXPORT_SIGN['$'] = xlsx2py.needReplace
EXPORT_SIGN['!'] = xlsx2py.isKey

def main():
	"""
		Instructions:
	python xlsx2py excelName.xls(x) data.py
	"""
	try:
		outfile = sys.argv[1]
	except:
		print( main.__doc__ )
		return
	
	for infile in sys.argv[2:]:
		Print( "Starting the guide: [%s] max=%i" % (infile, len(sys.argv[2:])) )
		if os.path.isfile(infile):
			a = xlsx2py(infile, outfile)
			xlsxtool.exportMenu(EXPORT_INFO_OK)
			a.run()
		else:
			xlsxError.error_input(EXPORT_ERROR_NOEXISTFILE, (infile,))
		print( '-------------------------------THE END------------------------------------------------' )
	
	sys.exit()
	
if __name__ == '__main__':
	main()
